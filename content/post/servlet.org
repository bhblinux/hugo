** ServletContext
   1. 获得web应用全局的初始化参数
      #+BEGIN_SRC 
      <context-param>
  	<param-name></param-name>
  	<param-value></param-value>
      </context-param>
      #+END_SRC
   2. 获得web应用中任何资源的绝对路径
      #+BEGIN_SRC 
      String path = context.getRealPath(相对于该web应用的相对地址);
      "/",".","" 获取到的路径都是一样的，是webapp目录项目的目录
      如果src目录下面有放资源文件，eclipse会将文件拷贝至WEB-INF\classes\下
      src
      文件放在src下 写WEB-INF\classes
      webapp
      /
         | WEB-INF
	 WEB-INF\
	 |   |classes
      #+END_SRC
   3. 域对像
** Responseyes
   1. 设置响应状态码
      #+BEGIN_SRC 
      setStatus(int sc);
      #+END_SRC
   2. 设置中文乱码
      #+BEGIN_SRC 
      setCharacterEncoding("utf-8");
      #+END_SRC
   3. 指定浏览器解析页面的编码方式
      #+BEGIN_SRC 
      setContentType("text/html;charset=UTF-8");
      #+END_SRC
   4. MIME(下载文件)
      #+BEGIN_SRC 
      1. response.setContentType(this.getServletContext().getMimeType(String filename))
      2. response.setHeader("Content-Disposition","attachment;filename="+filename);
      #+END_SRC
   5. 获取User-Agent
      #+BEGIN_SRC 
      request.getHeader("User-Agent");
      #+END_SRC
   6. 细节
      1. response获得的留不需要手动关闭，tomcat会自己关
      2. getWriter和getOutputStream 不能同时调用
** cookie
1. 创建cookie对象
 Cookie cookie=new Cookie("name","abc");
2. 发送cookie给客户端
   response.addCookie(cookie);



3. 设置持久化
   将cooke信息保存在硬盘上
   cookie.setMaxAge(10*60) 10分钟
4. 设置cookie携带路径
   cookie.setPath("/xx/xx"); 访问sendCookie资源时才携带cookie
   cookie.setPath("/xx"); 访问xx下的任何资源时都携带cookie

   cookie.setPath("/"); 访问服务器下的所有资源都携带cookie
   默认放在http;//xx/web1 下
5. 删除cookie
   cookie.setMaxAge(0);
  

   cooke.setPath("/"); 访问服务器下的所有资源都携带cookie
   默认放在http;//xx/web1 下
5. 删除cookie
   cookie.setMaxAge(0);
6. 获取cookie
   #+BEGIN_SRC 
   request.getCookies();
   #+END_SRC
** session
   =JESSIONID=
   1. 获取session
      #+BEGIN_SRC 
      reqeust.getsession();
      1. 如果客户端在此服务器不存在session,那么会创建session
      2. 如果客户端在此服务器存在session,则获取返回
      #+END_SRC
   2. 声明周期
      创建: 第一次执行request.getSession
      销毁:
      1. 服务器(非正常)关闭 
      2. session过期/失效(默认30分钟)
	 #+BEGIN_SRC 
	 在web.xml中进行配置
	 <session-config>
	 <sesssion-timout>30</session-timout>
	 </session-config>
	 #+END_SRC
      3. 手动销毁session
	 #+BEGIN_SRC 
	 session.invalidate()
	 #+END_SRC
** jsp
*** jsp脚本
    #+BEGIN_SRC 
    1. <% java代码%>
    2. <%=java变量或表达式%>

    #+END_SRC
*** jsp指令
**** page指令
     格式：<%@ page 属性名1= "属性值1" 属性名2= "属性值2" ...%>
     属性:
     1. language：jsp脚本中可以嵌入的语言种类
     2. pageEncoding：当前jsp文件的本身编码---内部可以包含contentType
     3. contentType：response.setContentType(text/html;charset=UTF-8)
     4. session：是否jsp在翻译时自动创建session
     5. import：导入java的包
     6. errorPage：当当前页面出错后跳转到哪个页面
     7. isErrorPage：当前页面是一个处理错误的页面
**** include指令
     页面包含（静态包含）指令，可以将一个jsp页面包含到另一个jsp页面中
     格式：<%@ include file="被包含的文件地址"%>
**** taglib指令
     在jsp页面中引入标签库（jstl标签库、struts2标签库）
     格式：<%@ taglib uri="标签库地址" prefix="前缀"%>
*** jsp内置对象/隐式对象
    1. out
       jspWriter
       out作用就是想客户端输出内容----out.write()
       out缓冲区默认8kb 可以设置成0 代表关闭out缓冲区 内容直接写到respons缓冲器
    2. request
    3. response
    4. config
       ServeltConfig 服务器配置，可以取得初始化参数
    5. session
       HttpSession 用来保存用户的信息
    6. application
       ServletContext 所有用户的共享信息
    7. page
       Object 指当前页面转换后的Servlet类的实例
    8. pageContext
       jsp页面的上下文对象，作用如下：
       page对象与pageContext对象不是一回事
       依次从pageContext域，request域，session域，application域中获取属性，在某个域中获取后将不在向后寻找
    9. exception
- 四大作用域的总结：
  page域：当前jsp页面范围
  request域：一次请求
  session域：一次会话
  application域：整个web应用
** EL 
*** 取值
    1. 获取四大域的数据
       #+BEGIN_SRC 
       ${pageScope.key}
       #+END_SRC
    2. 获取pageContext域中的值
       #+BEGIN_SRC 
       ${pageScope.key};
       #+END_SRC
    3. 获取request域中的值
       #+BEGIN_SRC 
       ${requestScope.key}
       #+END_SRC
    4. 获取session域中的值
       #+BEGIN_SRC 
       ${sessionScope.key}
       #+END_SRC
    5. 获取application域中的值
       #+BEGIN_SRC 
       ${application.key}
       #+END_SRC
*** el内置对象
    1. pageScope
    2. requestScope
    3. sessionScope
    4. applicationScope
    5. param 
       request.getParameter()
    6. paramValues
       request.getParameterVlues()
    7. iniParam 
       获取全局初始化参数
       this.getServletcontext().getInitParameter(name)
    8. cookie
       request.getCookies()---cookie.getName--cookie.getValue()
    9. pageContext
       pageContext获取其他8大对象
       ${pageContext.request.contextPath}
    10. header
	获取请求头信息
    11. headerValues
*** el执行表达式
    ${1+1}
    ${empty user}
    ${user == null?true:false}

** 错误页面
   web.xml设置web应用的全局的错误页面
   #+BEGIN_SRC 
   <error-page>
   <error-code>404</error-code>
   <location>/xx.jsp</location>
   </error-page>
   #+END_SRC

** 事务
   事务的隔离级别
   1. read uncommitted:读取尚未提交的数据:哪个问题都解决不了
   2. read committed:读取已提交的数据:可以解决脏读
   3. repeatable read:重复读取,可以解决脏读和不可重复读
   4. serializable:串行化:可以解决脏读 不可重复读和虚读

*** 查看mysql数据库默认隔离级别
    select @@tx_isolation

*** 设置隔离级别
    set session transaction isolation level [隔离级别]


** 监听器(Listener)
=======
>>>>>>> 6dd6ff71df68318e22516988cec27083df50b5f8

** 监听器(Listener)
   
*** 监听对象
    1. ServletContextListener
       监听servletcontext对象的创建和销毁，在web应用加载或者服务器启动是创建，在web应用卸载或服务器停止时销毁
    2. ServletContextAttributeListener
       对ServletContext对象里面的属性进行增删改功能
    3. ServletRequest
       监听request对象的创建和销毁，在用户发出请求时创建，在请求完毕后销毁
    4. ServletRequestAttributeListener
       对request对象里面的属性进行增删改功能
    5. HttpSessionListener
       经停session对象和销毁，在每个用户第一次调用request.getSession()方法创建，销毁的方法有很多总，默认30分钟，设置等待时间setMaxInactiveInteval(),在全局
       配置上配置等待时间<session-config><session-timeout></session-config>，手动销毁invalidate()
    6. HttpSessionAttributeListener
       对session对象里面的属性增删改操作



*** 配置监听器
    web.xml
    <listener>
     <listener-class>com.yonyou.xxx</listener-class>
    </listener>

** 过滤器(Filter)
  
*** 生命周期
    1. init():初始化，在创建过滤器对象的时候会被调用，在过滤器在web应用启动时候创建，只创建一次，
    2. doFilter():执行过滤的主要方法，用于过滤请求和响应，请求一次就调用一次，可以多次调用
    3. destory():销毁方法，过滤器对象销毁的时候会被调用，也只调用一次

*** web配置
    #+BEGIN_SRC 
    <filter></filter>
    <filter-mappping></filter-mapping>
    #+END_SRC
>>>>>>> ab06cddb4b8117992f9276341921528d4628adde
