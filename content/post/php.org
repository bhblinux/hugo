* php基础
** 函数
*** require
    包含文件,会生成一个致命的错误,停止执行
*** require_once  | 主要用
    会先判断是否已经包含
*** include
    把一个页面包含到另外一个页面,会生成一个警告,会继续执行
*** include_once
** 安装和启动
   #+BEGIN_SRC 
   启动
   php -S local:8080 -t thinkphp的目录
   #+END_SRC
*** 模板
    #+BEGIN_SRC 
    1. 需要在view目录下创建模板(没有不写)
    2. 在模板目录下创建于控制器相同名的目录
    3. 在创建模板html
     $this->theme("5000")->display();
    #+END_SRC
**** 模板赋值
     #+BEGIN_SRC 
     $this->name 
     
     #+END_SRC
**** 使用 
     #+BEGIN_SRC 
     echo $name
     #+END_SRC
*** 连接数据库
**** 数据库连接配置
     #+BEGIN_SRC 
     application/Conf/config.php
     'DB_TYPE' => "mysql',
     'DB_USER' => 'root',
     'DB_PWD' => '',密码
     'DB_PREFIX' =>'xx',//数据库表前缀
     'DB_DSN' => 'mysql:host=localhost:dbname=tp;charset=utf-8'
     #+END_SRC
** 基础
*** 变量
    局部转全局变量
    #+BEGIN_SRC 
    $name='abc';
    global或者$globals
    global $name; 作用1,将局部转全局变量,声明全局变量,在函数内部使用全局变量
    
    
    #+END_SRC
**** 变量的函数
     1. isset
     2. unset
     3. empty
     4. echo
     5. var_dump
*** 预定义变量
    1. $GLOBALS
       可以自动获取当前页面中的所有变量的内容
    2. $_SERVER
       自动获取服务器和客户端的信息
** 类
   #+BEGIN_SRC 
   <?php 
class person{
	public $name;
	public $age;
	public function __construct($name,$age){
		$this->name=$name;
		$this->age=$age;
	}
}

$p=new person("wangzla",18);
echo $p->name." ".$p->age;




 ?>
   #+END_SRC
*** 构造方法
    只能有一个没有重载
    #+BEGIN_SRC 
    public function __construct();
    #+END_SRC
*** 析构方法
    #+BEGIN_SRC
    function __destruct(){}
    #+END_SRC
    1. 析构的调用顺序,先创建的后被销毁 入栈的原理
    2. 什么时候被调用
       1. 进程结束
       2. 当一个对象成为垃圾对象的时候,就会被调用
*** 静态变量
    1. 定义
       #+BEGIN_SRC 
       public static $num;
       #+END_SRC
    2. 使用
       1. 类中访问
	  #+BEGIN_SRC 
	  self::$num
	  #+END_SRC
       2. 类外面访问
	  #+BEGIN_SRC 
	  类名::变量名
	  #+END_SRC

*** 全局变量
    #+BEGIN_SRC 
    global $name
    #+END_SRC

*** set|get
    #+BEGIN_SRC 
    public function __set($pro_name,$pro_val){
    $this->pro_name=$pro_val;
    }
    public function __get($pro_name){
    if(iiset($pro_name)){
    return $this->pro_name;
    else{
    return null;
    }
    }
    
    #+END_SRC

*** 继承
    子类继承父类不会自动调用父类的构造函数
    #+BEGIN_SRC 
    <?php 
class Person{
	public $name;
	public function __construct($name){
		$this->name=$name;
	}
	public function toString(){
		echo $this->name;
	}
}

class Student extends Person{

}

$p=new Person("wang");
$p->toString();
$s=new Student("liang");
$s->toString();

 ?>
    #+END_SRC

*** 抽象类
    #+BEGIN_SRC 
    abstract class test{
        abstract public function aa();
    {
    #+END_SRC
*** 接口
    定义 interface
    #+BEGIN_SRC 
    interface imm{
    public function start();
    public function stop();
    }
    #+END_SRC
    实现接口
    #+BEGIN_SRC 
    class aa implements imm{
    public function start(){}
    public function stop(){}
    }
    #+END_SRC
*** 魔术方法
**** __call
     调用一个对象的某个方法,而该方法不存在,则系统会自动调用__call

     #+BEGIN_SRC 
     
     #+END_SRC
*** 异常处理
    
