* go
** 基础

*** 赋值
    赋值语句不能再函数体外赋值，Name:="a" 自动推倒等价与 var Name string Name="a"
** 函数
*** 闭包
    可以理解为class
    其中变量为字段
    函数为方法
    #+BEGIN_SRC
    func funcA() func(int, int) int {
	var n int = 10
	return func(a, b int) int {
		n = a + b + n
		return a + b + n
	}
}
//使用
f := funcA()
	fmt.Println(f(1, 2))
	fmt.Println(f(1, 2))
    #+END_SRC
*** defer
    延时机制
    在函数执行完毕后，及时释放资源
    1。 当执行defer时，暂时不会执行，先将该语句压栈，
    1. 当函数执行完毕后，再执行
    2. 如果有变量，将会拷贝同时压栈
** 常用的函数
*** string
    1. 统计字符串的长度len(str)
    2. 字符串遍历,同时处理有中文的问题r:=[]rune(str)
    3. 字符串转整数 n,_:=strconv.Atoi("12")
    4. 整数转字符串 str=strconv.Itoa(1234)
    5. 字符串转[]byte var bytes=[]byte("hello")
    6. []byte 转字符串 str:=string([]byte{97,98,99})
    7. 10进制转2,8,16进制:str:=strconv.FormatInt(123,2)
    8. 查找子串是否在指定的字符串中:strings.Contains("seafood","foo")
    9. 统计一个字符串有几个指定的字串:strings.Count("ceheee","e")
    10. 不区分大小写的字符串比较(==是区分字母大小写):strings.EqualFold("abc","Abc")
    11. 返回字串在字符串第一次出现的index值,如果没有返回-1,strings.Inde("NLT_ABC","ABC")
    12. 返回字串在字符串最后一次出现的index值,LastIndex("go lang","go")
    13. 替换 string.Replase("go","aaa",-1) -1表示全部替换
    14. 分割 string.Split("heelo,go",",")
    15. 转大小写 string.ToLower("Go"),strings.ToUpper("Go")
    16. 将字符串左右两边的空格去掉，strings.TrimSpace(" aa ")
    17. 将字符串左右两边制定的字符strings.Trim(“1aaa1","1")
    18. 去掉字符串左边指定的字符strings.TrimLeft()
    19. 去掉字符串右变指定的字符strings.TrimRight()
    20. 判断字符串时是否以指定的字符串开头strings.HasPrefix("ftp:/aaa?","ftp")
    21. 判断字符串是否以指定指定的字符串结尾strings.HasSuffix("xxx.jpg","jpg")
*** time
***
***
***
    时间和日期
*** 字符串格式化
    %T 默认自动会推导数据类型
    %d 整形
    %t 布尔
    %ｐ指针
    1. fmt.Println()
    2. fmt.Printf()
    3. fmt.Sprintf()
** 错误处理
*** defer
*** panic
    将会中断程序
    #+BEGIN_SRC
    func test1() {
	defer func() {
		err := recover()
		if err != nil {
			panic(errors.New("我是自定义错误"))
		}
	}()
	num := 10
	num2 := 0
	res := num / num2
	fmt.Println("res=", res)
}
    #+END_SRC
*** recover
*** 案例
    #+BEGIN_SRC
    func test() {
	defer func() {
	//err := recover() //recover（）内置函数，可以捕获到异常
		if erro:=recover();err != nil {
			fmt.Println(err)
		}
	}()
	num := 10
	num2 := 0
	res := num / num2
	fmt.Println("res=", res)
}
func main() {
	//闭包
	// f := funcA()
	// fmt.Println(f(1, 2))
	// fmt.Println(f(1, 2))
	test()
}

    #+END_SRC
*** 自定义错误
**** errors.New()
     #+BEGIN_SRC
     errors.New("我是自定义错误")
     #+END_SRC
**** painc
     #+BEGIN_SRC
     painc(errors.NEW("自定义错误"))
     #+END_SRC
** 数组
   值拷贝类型
*** 初始化数组
    1. var arr [3]int=[3]int{1,2,3}
    2. var arr =[]int{1,2,3}
    3. var arr=[...]int{1,2,3}
    4. var arr=[...]int{1:800,0:100，2:300}
    5. arr:=[...]string{"a","B"}
*** 遍历数组
    #+BEGIN_SRC
    for index,value:=range array{}
    说明:
    1. index是返回数组的下标
    2. value 该下标的值
    3. 他们都是局部变量
    4. 如果不想要这些用_过滤
    5. 可以自行定义变量名,
    #+END_SRC
** 切片
   引用类型
   1. var a[] int
   2. var slice [] int =make ([]int ,4,10)//4 接片的大小，10 接片的容量
   3. 定义一个切片，直接就指定具体数组，
      #+BEGIN_SRC
      var strclice [] string=[]string{"a","b","c"}
      #+END_SRC
** map
   引用类型
   1. 定义
       #+BEGIN_SRC
   var map变量名 map[keytype] valuetype
   var map1 map[string]string=make(map[string]string)
   #+END_SRC
   2. 方式二
      #+BEGIN_SRC
      var map2=make(map[string]string)
      #+END_SRC
   3. 方式三
      #+BEGIN_SRC
      var map3[string]string=map[string]string{
      "name":"liang"
      }
      #+END_SRC
   4. 查找
      findres
      v, f := a["name"] //如果找到 f为返回结果，找到为true，否则为false
** OOP
*** 结构体struct
    结构体是值类型,备份的时候为值拷贝
    1. 定义
       #+BEGIN_SRC
       type Cat struct {
           Name string
           Age int
     }
     //定义tostring
     func (p Cat) String() string{
     return fmt.Sprintf("%s,%d",p.Name,p.Age)
     }
       #+END_SRC
    2. 使用
       #+BEGIN_SRC
       func main(){
	var Cat1 Cat
        //或者
        Cat2:=Cat{}
        //
        Cat2:=Cat{"liang",12}
	Cat1.Name="liang"
	Cat1.Age=1
	fmt.Println(Cat1)
	}
       #+END_SRC
    3. 创建结构提的方式
       1. var p *Person=new (Person)
          （×p).Name="liang"
          p.Name="liang""
       2. var p *Person=&Person{}
*** 方法
    1. 定义
       #+BEGIN_SRC
       func (a A)test() ) 表示A结构体有一方法，方法名为test
       #+END_SRC

*** 工厂模式
     相当与java中的构造函数功能
*** 封装
*** 继承
    1. 匿名结构体来实现
       #+BEGIN_SRC
     type Person struct{
     Name string
     Age int

}
type Student struct{
     Person
     Id int

}
func (p Person) Speak(){
     fmt.Println(p.Name,"诞生了")
}

func main(){
     stu:=Student{}
     stu.Person.Name="liang"
     stu.Id=1
     fmt.Println(stu)


}
    #+END_SRC

    2. 匿名字段

       #+BEGIN_SRC
    type Person struct{
     int
    }
    #+END_SRC
*** 接口(Interface)
      #+BEGIN_SRC
      package main
import "fmt"
//定义接口
type Usb interface{
     Start()
     Stop()
}
//接口实现
type Phone struct{
}
func (p Phone) Start(){
     fmt.Println("手机开始工作。。。。")
}
func (p Phone) Stop(){
     fmt.Println("手机停止工作。。。。")
}
type Computer struct{
}
func (c Computer) Working(usb Usb){
     usb.Start()
     usb.Stop()
}
func main(){
     c:=Computer{}
     p:=Phone{}
     c.Working(p)
}
      #+END_SRC
**** 接口案例
     #+BEGIN_SRC

     #+END_SRC
**** 接口实例
     #+BEGIN_SRC

package main

import (
	"fmt"
	"math/rand"
	"sort"
)

type Person struct {
	Age  int
	Name string
}

//声明结构体切片
type PSlice []Person

//实现Ｓort接口
func (ps PSlice) Len() int {
	return len(ps)
}
func (ps PSlice) Less(i, j int) bool {
	return ps[i].Age < ps[j].Age
}
func (ps PSlice) Swap(i, j int) {
	ps[i], ps[j] = ps[j], ps[i]
}

func main() {
	var ps PSlice
	for i := 0; i < 4; i++ {
		p := Person{}
		p.Name = fmt.Sprintf("name%d", rand.Intn(10))
		p.Age = rand.Intn(10)
		ps = append(ps, p)
	}
	sort.Sort(ps)
	fmt.Println(ps)
}

import (
	"fmt"
	"math/rand"
	"sort"
)

type Person struct {
	Age  int
	Name string
}

//声明结构体切片
type PSlice []Person

//实现Ｓort接口
func (ps PSlice) Len() int {
	return len(ps)
}
func (ps PSlice) Less(i, j int) bool {
	return ps[i].Age < ps[j].Age
}
func (ps PSlice) Swap(i, j int) {
	ps[i], ps[j] = ps[j], ps[i]
}

func main() {
	var ps PSlice
	for i := 0; i < 4; i++ {
		p := Person{}
		p.Name = fmt.Sprintf("name%d", rand.Intn(10))
		p.Age = rand.Intn(10)
		ps = append(ps, p)
	}
	sort.Sort(ps)
	fmt.Println(ps)
}
     #+END_SRC
*** 多态
** 文件
*** OS
    1. FILE
       #+begin_src
func main() {
	file, err := os.Open("/home/bhblinux/1.txt")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(file)

	err = file.Close()
	if err != nil {
		fmt.Println(err)
	}

}
       #+end_src
    2. EOF
       文件的结尾
       #+begin_src package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

func main() {
	file, err := os.Open("/home/bhblinux/1.txt")
	if err != nil {
		fmt.Println(err)
	}
	buf := bufio.NewReader(file)
	for {
		line, _, err := buf.ReadLine()
		if err == io.EOF {
			break
		}
		fmt.Println(string(line))
	}
	//当函数退出时，要及时关闭
	defer file.Close()
}


       #+end_src
    3. 读文件二
       #+begin_src
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	filename := "/home/bhblinux/1.txt"
	content, _ := ioutil.ReadFile(filename)
//该方式不需要手动关闭文件，适用于小文件
	fmt.Println(string(content))

}

       #+end_src
    4. 写文件
       #+begin_src
package main
import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	filepath := "/home/bhblinux/2.txt"
	file, err := os.OpenFile(filepath, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()
	str := "hello go\n"
	buf := bufio.NewWriter(file)
	for i := 0; i < 5; i++ {
		buf.WriteString(str)
	}
	buf.Flush()
}
       #+end_src
*** BUFIO
*** flag
    1. StringVar
       1. 接受用户的命令行中的输入
       2. 指定的参数 u -u的意思
       3. 默认值
       4. 用户名，默认为空，说明
    2. Parse
       注册解析
    3. JSON
*** testing
   测试框架
   1. go test
     #+begin_src go
 package main
import (
	"fmt"
	"testing"
)
func TestAdd(t *testing.T) {
	res := Add(10)
	if res != 33 {
		t.Fatalf("%v", res)
	}
	fmt.Println("计算正确")
	t.Logf("执行正确")
}


      #+end_src
*** goroutine(携程)
    #+begin_src
package main
import ("fmt"
"time")
func hello(){
     for i:=0;i<10;i++{
         fmt.Println("hello hello ....")
         time.Sleep(time.Second)
     }
}
func main(){
     go hello()
     for i :=0;i<10;i++{
     fmt.Println("main")
         time.Sleep(time.Second)
     }

}
    #+end_src
