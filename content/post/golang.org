* go
** 基础

*** 赋值
    赋值语句不能再函数体外赋值，Name:="a" 自动推倒等价与 var Name string Name="a"
    1. 声明一个变量
       #+begin_src 
      var name type
      name=value
       #+end_src
    2. 类型推断Type inference
       如果一个变量有一个初始值，go将自动能够使用初始值来推断该变量的类型
       #+begin_src 
      var name=value 
       #+end_src
    3. 省略var，注意:=左侧的变量不应该是已经声明过的(多个变量同事声明时，至少保证一个是新变量),否则会导致编译错误
       #+begin_src 
      name:=value
      var a int=10
      var b=10
      c:=10
       #+end_src
    4. 多变量声明
       1. 已逗号分隔,声明与赋值分开，若不赋值，存在默认值
          #+begin_src 
         var name1,name2,name3 type
         name1,name2,name3=v1,v2,v3
          #+end_src
       2. 直接赋值
          #+begin_src 
         var name1,name2,name3=v1,v2,v3 
          #+end_src
       3. 集合类型
          #+begin_src 
         var(
         name1 type1
         name2 type2
         )
          #+end_src
    5. 常亮声明
       const identifier [type]=value
       常量在程序运行时，不会被修改
       可以是布尔，数字，字符串
       不增使用的常量，在编译的时候，不会报错
       显示类型定义：const b string="abc
       隐士类型定义：const b="abc"
       #+begin_src 
      const(
      x uint16=16
      y
      s="abc"
      z
      ) 
      常量组中如果不指定类型和初始值，则与上一行非空常量右值相同
       #+end_src
    6. iota
       特殊的常量，可以被编译器修改的常量
       在每一个const关键字出现时，被重置为0,然后再下一个const出现之前,没出现一次iota，其所代表的数字会自动增加1
       #+begin_src 
       const(
       a=iota
       b=iota
       c=iota
       )
       可以简写
       const(
       a=iota
       b
       c
       )
       a=0,b=1,c=2
       #+end_src

** 分支循环
   
*** 条件语句
    
**** if语句
     #+begin_src 
     if 布尔表达式{}
     if 布尔表达式{}else{}
     if 布尔表达式１{}else if 布尔表达式２{}else{}
     如果其中包含一个可选的语句组件，还有一个变体
     if statement;condition{}
     if num:=10;num%2==0{}
     #+end_src

**** switch 
     #+begin_src 
     switch var1{
         case var1:
         ...
         case val2:
         ...
         default:
         ...
     }

     #+end_src
     如果需要贯穿后续的case,就添加fallthrough,fallthroug应该是某个case最后一个,如果它出现在中间的某个地方,编译器就会抛出错误
     #+begin_src go
func main(){
	switch x:=5;x{
	default:
		fmt.Println(x)
	case 5:
		x+=10
		fmt.Println(x)
		fallthrough
	case 6:
		x+=20
		fmt.Println(x)
	}
}
     #+end_src
     case中的表达式是可选的，可以省略,如果改表达式被省略,则被认为switch true,并且每个case表达式都被计算为true,并执行相应的代码块
     
     switch语句还可以被用于type-switch来判断某个interface变量中实际存储的变量类型
     #+begin_src go
     switch x.(type){
     case type:
         statement(s);
     case type:
         statement(s);
     default
         statement(s);
     }
}package main

import "fmt"

func main() {
   var x interface{}

   switch i := x.(type) {
      case nil:
         fmt.Printf(" x 的类型 :%T",i)
      case int:
         fmt.Printf("x 是 int 型")
      case float64:
         fmt.Printf("x 是 float64 型")
      case func(int) float64:
         fmt.Printf("x 是 func(int) 型")
      case bool, string:
         fmt.Printf("x 是 bool 或 string 型" )
      default:
         fmt.Printf("未知型")
   }
}
     
     #+end_src
     
**** select
     select语句类似于switch语句,但是select会随机执行一个可运行的case，如果没有case可运行,他将阻塞,直到有case可运行
     - 注意
       1. 每个case都必须是一个通信
       2. 所有channel表达式都会被求值
       3. 所有被发送的表达式都会被求值
       4. 如果任意某个通信可以进行,他就执行,其他会被忽略
       5. 如果多个case都可以运行,select会随机公平的选出一个执行,其他不会被执行
       6. 如果有default字句,则执行该语句
       7. 如果没有default语句,select将阻塞,直到某个通信可以运行,go不会重新对channel或值进行求值

**** for
     for init;condition;post{}
     初始化语句只执行一次,在初始化循环之后,将检查该条件,如果条件计算为true,那么{}中的循环体将被执行,然后是post语句,post语句将再循环的每次成功迭代之后执行,在执行post语句之后,该条件
     被重新检查,如果正确继续执行,否则停止
     for;;{}
     for{}死循环
     
**** goto
     可以无条件的转移到过程中指定的行
     

** 函数
*** 闭包
    可以理解为class
    其中变量为字段
    函数为方法
    #+BEGIN_SRC
    func funcA() func(int, int) int {
	var n int = 10
	return func(a, b int) int {
		n = a + b + n
		return a + b + n
	}
}
//使用
f := funcA()
	fmt.Println(f(1, 2))
	fmt.Println(f(1, 2))
    #+END_SRC
*** defer
    延时机制
    在函数执行完毕后，及时释放资源
    1。 当执行defer时，暂时不会执行，先将该语句压栈，
    1. 当函数执行完毕后，再执行
    2. 如果有变量，将会拷贝同时压栈
** 常用的函数
*** string
    1. 统计字符串的长度len(str)
    2. 字符串遍历,同时处理有中文的问题r:=[]rune(str)
    3. 字符串转整数 n,_:=strconv.Atoi("12")
    4. 整数转字符串 str=strconv.Itoa(1234)
    5. 字符串转[]byte var bytes=[]byte("hello")
    6. []byte 转字符串 str:=string([]byte{97,98,99})
    7. 10进制转2,8,16进制:str:=strconv.FormatInt(123,2)
    8. 查找子串是否在指定的字符串中:strings.Contains("seafood","foo")
    9. 统计一个字符串有几个指定的字串:strings.Count("ceheee","e")
    10. 不区分大小写的字符串比较(==是区分字母大小写):strings.EqualFold("abc","Abc")
    11. 返回字串在字符串第一次出现的index值,如果没有返回-1,strings.Inde("NLT_ABC","ABC")
    12. 返回字串在字符串最后一次出现的index值,LastIndex("go lang","go")
    13. 替换 string.Replase("go","aaa",-1) -1表示全部替换
    14. 分割 string.Split("heelo,go",",")
    15. 转大小写 string.ToLower("Go"),strings.ToUpper("Go")
    16. 将字符串左右两边的空格去掉，strings.TrimSpace(" aa ")
    17. 将字符串左右两边制定的字符strings.Trim(“1aaa1","1")
    18. 去掉字符串左边指定的字符strings.TrimLeft()
    19. 去掉字符串右变指定的字符strings.TrimRight()
    20. 判断字符串时是否以指定的字符串开头strings.HasPrefix("ftp:/aaa?","ftp")
    21. 判断字符串是否以指定指定的字符串结尾strings.HasSuffix("xxx.jpg","jpg")
*** time
***
***
***
    时间和日期
*** 字符串格式化
    %T 默认自动会推导数据类型
    %d 整形
    %t 布尔
    %ｐ指针
    1. fmt.Println()
    2. fmt.Printf()
    3. fmt.Sprintf()
** 错误处理
*** defer
*** panic
    将会中断程序
    #+BEGIN_SRC
    func test1() {
	defer func() {
		err := recover()
		if err != nil {
			panic(errors.New("我是自定义错误"))
		}
	}()
	num := 10
	num2 := 0
	res := num / num2
	fmt.Println("res=", res)
}
    #+END_SRC
*** recover
*** 案例
    #+BEGIN_SRC
    func test() {
	defer func() {
	//err := recover() //recover（）内置函数，可以捕获到异常
		if erro:=recover();err != nil {
			fmt.Println(err)
		}
	}()
	num := 10
	num2 := 0
	res := num / num2
	fmt.Println("res=", res)
}
func main() {
	//闭包
	// f := funcA()
	// fmt.Println(f(1, 2))
	// fmt.Println(f(1, 2))
	test()
}

    #+END_SRC
*** 自定义错误
**** errors.New()
     #+BEGIN_SRC
     errors.New("我是自定义错误")
     #+END_SRC
**** painc
     #+BEGIN_SRC
     painc(errors.NEW("自定义错误"))
     #+END_SRC
** 数组
   值拷贝类型
*** 初始化数组
    var variable_name [size] variable_type
    var balance [10] float32
    var balance =[5]float32{1.0,2.0,4.0,5.0}
    1. var arr [3]int=[3]int{1,2,3}
    2. var arr =[]int{1,2,3}
    3. var arr=[...]int{1,2,3}
    4. var arr=[...]int{1:800,0:100，2:300}
    5. arr:=[...]string{"a","B"}
*** 遍历数组
    #+BEGIN_SRC
    for index,value:=range array{}
    说明:
    1. index是返回数组的下标
    2. value 该下标的值
    3. 他们都是局部变量
    4. 如果不想要这些用_过滤
    5. 可以自行定义变量名,
    #+END_SRC
** 切片
   引用类型
   var identifier []type
   var slice1[]type=make([]type,len)
   1. var a[] int
   2. var slice [] int =make ([]int ,4,10)//4 接片的大小，10 接片的容量
   3. 定义一个切片，直接就指定具体数组，
      #+BEGIN_SRC
      var strclice [] string=[]string{"a","b","c"}
      #+END_SRC
   4. len and cap
      len　获取长度
      cap　获取切片最长可以达多少
   5. append
      向切片里追加一个或多个元素，然后返回一个和slice一样类型的切片
      #+begin_src 
      slice1=append(slice1,100)
      #+end_src
   6. ｃopy
      从源slice的src中复制元素到dst，并且返回复制的元素个数
      #+begin_src 
      n := copy(slice2, slice1)
      #+end_src

** map
   引用类型
   map是无序的，需要通过key来获取
   map的长度是不固定的，也就是和slice一样，引用类型
   内置len函数同样试用于map,返回map拥有的key的数量
   map的key可以是所有可比较的类型,如布尔，整数，浮点，复杂，字符串
   不初始化的map,是不能存放键值对的
   1. 定义
       #+BEGIN_SRC
   var map变量名 map[keytype] valuetype
   var map1 map[string]string=make(map[string]string)
   #+END_SRC
   2. 方式二
      #+BEGIN_SRC
      var map2=make(map[string]string)
      #+END_SRC
   3. 方式三
      #+BEGIN_SRC
      var map3[string]string=map[string]string{
      "name":"liang"
      }
      #+END_SRC
   4. 查找
      findres
      v, f := a["name"] //如果找到 f为返回结果，找到为true，否则为false
   5. 遍历
      #+begin_src 
      package main
import "fmt"
func main() {
	var map1 = make(map[string]string)
	map1["France"] = "Paris"
	map1["China"] = "beijing"
	for contry := range map1 {
		fmt.Println(contry, map1[contry])
	}
}
      #+end_src
   6. 删除
      delete(map,key)删除函数不返回任何值
   7. ok-idiom
      可以通过key获取map中对应的value值，
      当key如果不存在的时候，我们会得到该value值类型的默认值，比如string类型得到空字符串，int类型为０，程序不会报错
   8. make
      只能创建slice,map,channel，并返回一个有初始值,
   9. new
      分配了内存空间，并返回其地址*t类型

** 指针
   1. 声明
      var var_name *var-type
      var ip *int
      var fp *float32

      
** 结构体
   1. 定义和初始化
      #+begin_src 
      type struct_var_type struct{
      member definition;
      }
      variable_name:=struct_var_type{value1,valur2,..}
      #+end_src
   2. 初始化
      1. 按照顺序提供初始化值
         p:=person{"tom",25}
      2. 通过field:value的方式初始化
         ｐ:=person{age:23,name:"tom"}
      3. new方式,未设置初始化值，会赋予类的默认初始化值
         p:=new(person)
         p.age=24
      4. 结构体指针
         var struct_pointer *Books
         struct_pointer=&Book1
         var p *person = &Person{}
         //可以简化写成
         p:=&Person{}
         p := &Books{}
	       fmt.Println("aaa", p.Title)
	       p.Title = "golang"
         //编译器做了简化
         //(*p).Title="golang"
         做参数的时候会
         //(*p).printBook()
	       fmt.Println(p)
	       p.printBook()
** OOP

*** 结构体struct
    结构体是值类型,备份的时候为值拷贝
    1. 定义
       #+BEGIN_SRC
       type Cat struct {
           Name string
           Age int
     }
     //定义tostring
     func (p Cat) String() string{
     return fmt.Sprintf("%s,%d",p.Name,p.Age)
     }
       #+END_SRC
    2. 使用
       #+BEGIN_SRC
       func main(){
	var Cat1 Cat
        //或者
        Cat2:=Cat{}
        //
        Cat2:=Cat{"liang",12}
	Cat1.Name="liang"
	Cat1.Age=1
	fmt.Println(Cat1)
	}
       #+END_SRC
    3. 创建结构提的方式
       1. var p *Person=new (Person)
          （×p).Name="liang"
          p.Name="liang""
       2. var p *Person=&Person{}
*** 方法
    1. 定义
       #+BEGIN_SRC
       func (a A)test() ) 表示A结构体有一方法，方法名为test
       #+END_SRC

*** 工厂模式
     相当与java中的构造函数功能
*** 封装
*** 继乘
    通过匿名字段实现继承
    method是可以继承的，如果匿名字段实现了一个method,那么这个匿名字段的struct也能调用该method 
    如果嵌入的是一个切片，则匿名字段会报错，需要指定字段名 posts[]post
    1. 匿名结构体来实现
       #+BEGIN_SRC
     type Person struct{
     Name string
     Age int

}
type Student struct{
     Person
     Id int

}
func (p Person) Speak(){
     fmt.Println(p.Name,"诞生了")
}

func main(){
     stu:=Student{}
     stu.Person.Name="liang"
     stu.Id=1
     fmt.Println(stu)


}
    #+END_SRC
    2. 匿名字段
       #+BEGIN_SRC
    type Person struct{
     int
    }
    #+END_SRC
    方法是可以继承和重写的,
    存在继承关系时，按照就近原则,进行调用
    #+begin_src 
    package main

import "fmt"

type Human struct {
	name  string
	age   int
	phone string
}
type Student struct {
	Human
	school string
}
type Employee struct {
	Human
	company string
}
func (h *Human) SayHi() {
	fmt.Printf("hi i am %s you can call me on %s\n", h.name, h.phone)
}
func (e *Employee) SayHi() {
	fmt.Println("employee")
}
func main() {
	mark := Student{Human{"mark", 25, "10086"}, "qinghua"}
	sam := Employee{Human{"sam", 45, "10010"}, "google"}
	mark.SayHi()
	sam.SayHi()
	fmt.Println(sam.age)
}

    #+end_src
*** 接口(Interface)
    1. 定义接口
       #+begin_src 
       type interface_name interface{
       method_name1 [return_type]
       method_name2 [return_type]
       method_name3 [return_type]
       method_name4 [return_type]
       }
       #+end_src

    2. 定义结构体
       #+begin_src 
       type struct_name struct{}
       #+end_src

    3. 实现接口的方法
       #+begin_src 
       func (struct_name variable struct_name) method_name1()[return_type]{/*方法实现*/}
       #+end_src

    interface可以被任意的对象实现
    一个对象可以实现任意多个interface
    任意的类型都实现了空接口(interface{}),也就是包含0个methomd的interface
    案例 
      #+BEGIN_SRC
      package main
import "fmt"
//定义接口
type Usb interface{
     Start()
     Stop()
}
//接口实现
type Phone struct{
}
func (p Phone) Start(){
     fmt.Println("手机开始工作。。。。")
}
func (p Phone) Stop(){
     fmt.Println("手机停止工作。。。。")
}
type Computer struct{
}
func (c Computer) Working(usb Usb){
     usb.Start()
     usb.Stop()
}
func main(){
     c:=Computer{}
     p:=Phone{}
     c.Working(p)
}
      #+END_SRC
**** 接口案例
     #+BEGIN_SRC

     #+END_SRC
**** 接口实例
     #+BEGIN_SRC

package main

import (
	"fmt"
	"math/rand"
	"sort"
)

type Person struct {
	Age  int
	Name string
}

//声明结构体切片
type PSlice []Person

//实现Ｓort接口
func (ps PSlice) Len() int {
	return len(ps)
}
func (ps PSlice) Less(i, j int) bool {
	return ps[i].Age < ps[j].Age
}
func (ps PSlice) Swap(i, j int) {
	ps[i], ps[j] = ps[j], ps[i]
}

func main() {
	var ps PSlice
	for i := 0; i < 4; i++ {
		p := Person{}
		p.Name = fmt.Sprintf("name%d", rand.Intn(10))
		p.Age = rand.Intn(10)
		ps = append(ps, p)
	}
	sort.Sort(ps)
	fmt.Println(ps)
}

import (
	"fmt"
	"math/rand"
	"sort"
)

type Person struct {
	Age  int
	Name string
}

//声明结构体切片
type PSlice []Person

//实现Ｓort接口
func (ps PSlice) Len() int {
	return len(ps)
}
func (ps PSlice) Less(i, j int) bool {
	return ps[i].Age < ps[j].Age
}
func (ps PSlice) Swap(i, j int) {
	ps[i], ps[j] = ps[j], ps[i]
}

func main() {
	var ps PSlice
	for i := 0; i < 4; i++ {
		p := Person{}
		p.Name = fmt.Sprintf("name%d", rand.Intn(10))
		p.Age = rand.Intn(10)
		ps = append(ps, p)
	}
	sort.Sort(ps)
	fmt.Println(ps)
}
     #+END_SRC
*** 多态
** 文件
*** OS
    1. FILE
       #+begin_src
func main() {
	file, err := os.Open("/home/bhblinux/1.txt")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(file)

	err = file.Close()
	if err != nil {
		fmt.Println(err)
	}

}
       #+end_src
    2. EOF
       文件的结尾
       #+begin_src package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

func main() {
	file, err := os.Open("/home/bhblinux/1.txt")
	if err != nil {
		fmt.Println(err)
	}
	buf := bufio.NewReader(file)
	for {
		line, _, err := buf.ReadLine()
		if err == io.EOF {
			break
		}
		fmt.Println(string(line))
	}
	//当函数退出时，要及时关闭
	defer file.Close()
}


       #+end_src
    3. 读文件二
       #+begin_src
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	filename := "/home/bhblinux/1.txt"
	content, _ := ioutil.ReadFile(filename)
//该方式不需要手动关闭文件，适用于小文件
	fmt.Println(string(content))

}

       #+end_src
    4. 写文件
       #+begin_src
package main
import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	filepath := "/home/bhblinux/2.txt"
	file, err := os.OpenFile(filepath, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()
	str := "hello go\n"
	buf := bufio.NewWriter(file)
	for i := 0; i < 5; i++ {
		buf.WriteString(str)
	}
	buf.Flush()
}
       #+end_src
*** BUFIO
*** flag
    1. StringVar
       1. 接受用户的命令行中的输入
       2. 指定的参数 u -u的意思
       3. 默认值
       4. 用户名，默认为空，说明
    2. Parse
       注册解析
    3. JSON
*** testing
   测试框架
   1. go test
     #+begin_src go
 package main
import (
	"fmt"
	"testing"
)
func TestAdd(t *testing.T) {
	res := Add(10)
	if res != 33 {
		t.Fatalf("%v", res)
	}
	fmt.Println("计算正确")
	t.Logf("执行正确")
}


      #+end_src
** goroutine(携程)
    #+begin_src
package main
import ("fmt"
"time")
func hello(){
     for i:=0;i<10;i++{
         fmt.Println("hello hello ....")
         time.Sleep(time.Second)
     }
}
func main(){
     go hello()
     for i :=0;i<10;i++{
     fmt.Println("main")
         time.Sleep(time.Second)
     }

}
    #+end_src
** 并发
   1. 测试程序是否存在资源竞争问题，
      #+begin_src go
      go build -race *.go 可以测试出程序是否存在资源竞争问题

      #+end_src
** channel
**** 锁（lock)
     sync 包
     #+begin_src go
     lock.Lock()
     ...代码
     lock.Unlock()
     互斥锁
     lock sync.Mutex 定义


     #+end_src
**** 定义
     #+begin_src go
     var 变量 chan 数据类型
     var intChan chan int(intchan 用于放int数据)
     channel 是引用数据类型
     channel 必须初始化才能写入数据，需要make
     管道是有类型的，
     #+end_src
**** 操作
     #+begin_src go
     var intChan chan int
     intChan=make(chan int ,3)
     //往管道写入数据
     intChan <- 10
     num:=211
     incChan <- num

     #+end_src
**** 关闭
     关闭管道,不可以在写入,可以读取数据
     #+begin_src go
     close(intChan)
     #+end_src
**** 遍历
     支持for-range
     1. 在遍历时,如果channel没有关闭,则会出现deadlock错误
     2. 在遍历时,如果channel已经关闭,则会正常遍历数据,遍历完后,就会退出遍历
**** 错无处理
     1. defer+recover
        #+begin_src go
           defer func(){
                //捕获异常
          if err:=recover(); err!=nil{
	fmt.Println("异常")


          }

                        }}

        #+end_src
** 反射
   1. 包
      reflect
   2. 转换
      1. interface()转成reflect.Value
         #+begin_src 
        rVal:=reflect.ValueOf(b) 
         #+end_src
      2. reflect.Value转interface{}
         #+begin_src 
        iVal:=rVal.interface{} 
         #+end_src
      3. interface{}转原来的变量
         #+begin_src 
        val:=iVal.(Stu) 
         #+end_src
      4. Kind
         reflect.Value.Kind 获取变量的类别，返回一个常量
         type是类型，Kind是类别，
         int Type是int Kind是int
         var stu Student stu的Type是包名.Student,Kind是struct
      5. Elem
         rVal.Elem()可以先将指针取出来之后在赋值
         #+begin_src go
func reflect01(b interface{}) {
	//通过反射获取value
	rVal := reflect.ValueOf(b)
	//查看rVal的Kind
	fmt.Printf("rVal kind=%v\n", rVal.Kind())
	rVal.Elem().SetInt(20)
}

func main() {
	var num int = 10
	reflect01(&num)
	fmt.Println(num)

}


         #+end_src
** 网络编程
   net
** json 
   1. 包
      #+begin_src 
      encoding/json
      
      #+end_src

   2. 序列化
      #+begin_src 
      data,_:=json.Marshal(&p)
      fmt.Prinltn(string(data))
      #+end_src

   3. 反序列化
      #+begin_src go
     var p personInfo
     str:="{"name":"laing","age":20,"email":"bhblinux@mail.com"}"
     err:=json.Unmarshal([]byte(str),&p1)
      #+end_src

      
